// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.Text;
using Microsoft.Agents.AI.Workflows.Generators.Models;

namespace Microsoft.Agents.AI.Workflows.Generators.Generation;

/// <summary>
/// Generates source code for executor route configuration.
/// </summary>
internal static class SourceBuilder
{
    /// <summary>
    /// Generates the source code for an executor's route configuration.
    /// </summary>
    public static string Generate(ExecutorInfo info)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Using directives
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using Microsoft.Agents.AI.Workflows;");
        sb.AppendLine();

        // Namespace
        if (!string.IsNullOrEmpty(info.Namespace))
        {
            sb.AppendLine($"namespace {info.Namespace};");
            sb.AppendLine();
        }

        // Handle nested classes
        var indent = "";
        if (info.IsNested)
        {
            foreach (var containingType in info.ContainingTypeChain.Split('.'))
            {
                sb.AppendLine($"{indent}partial class {containingType}");
                sb.AppendLine($"{indent}{{");
                indent += "    ";
            }
        }

        // Class declaration
        sb.AppendLine($"{indent}partial class {info.ClassName}{info.GenericParameters}");
        sb.AppendLine($"{indent}{{");

        var memberIndent = indent + "    ";

        // Generate ConfigureRoutes
        GenerateConfigureRoutes(sb, info, memberIndent);

        // Generate ConfigureSentTypes if needed
        if (info.ShouldGenerateProtocolOverrides)
        {
            sb.AppendLine();
            GenerateConfigureSentTypes(sb, info, memberIndent);
            sb.AppendLine();
            GenerateConfigureYieldTypes(sb, info, memberIndent);
        }

        // Close class
        sb.AppendLine($"{indent}}}");

        // Close nested classes
        if (info.IsNested)
        {
            var containingTypes = info.ContainingTypeChain.Split('.');
            for (int i = containingTypes.Length - 1; i >= 0; i--)
            {
                indent = new string(' ', i * 4);
                sb.AppendLine($"{indent}}}");
            }
        }

        return sb.ToString();
    }

    private static void GenerateConfigureRoutes(StringBuilder sb, ExecutorInfo info, string indent)
    {
        sb.AppendLine($"{indent}protected override RouteBuilder ConfigureRoutes(RouteBuilder routeBuilder)");
        sb.AppendLine($"{indent}{{");

        var bodyIndent = indent + "    ";

        // Call base if needed
        if (info.BaseHasConfigureRoutes)
        {
            sb.AppendLine($"{bodyIndent}routeBuilder = base.ConfigureRoutes(routeBuilder);");
            sb.AppendLine();
        }

        // Generate handler registrations
        if (info.Handlers.Length == 1)
        {
            // Single handler - return directly
            var handler = info.Handlers[0];
            sb.AppendLine($"{bodyIndent}return routeBuilder");
            sb.Append($"{bodyIndent}    .AddHandler");
            AppendHandlerGenericArgs(sb, handler);
            sb.AppendLine($"(this.{handler.MethodName});");
        }
        else
        {
            // Multiple handlers - chain calls
            sb.AppendLine($"{bodyIndent}return routeBuilder");

            for (int i = 0; i < info.Handlers.Length; i++)
            {
                var handler = info.Handlers[i];
                var isLast = i == info.Handlers.Length - 1;

                sb.Append($"{bodyIndent}    .AddHandler");
                AppendHandlerGenericArgs(sb, handler);
                sb.Append($"(this.{handler.MethodName})");

                if (isLast)
                {
                    sb.AppendLine(";");
                }
                else
                {
                    sb.AppendLine();
                }
            }
        }

        sb.AppendLine($"{indent}}}");
    }

    private static void AppendHandlerGenericArgs(StringBuilder sb, HandlerInfo handler)
    {
        if (handler.HasOutput && handler.OutputTypeName != null)
        {
            sb.Append($"<{handler.InputTypeName}, {handler.OutputTypeName}>");
        }
        else
        {
            sb.Append($"<{handler.InputTypeName}>");
        }
    }

    private static void GenerateConfigureSentTypes(StringBuilder sb, ExecutorInfo info, string indent)
    {
        sb.AppendLine($"{indent}protected override ISet<Type> ConfigureSentTypes()");
        sb.AppendLine($"{indent}{{");

        var bodyIndent = indent + "    ";

        sb.AppendLine($"{bodyIndent}var types = base.ConfigureSentTypes();");

        // Add class-level send types
        foreach (var type in info.ClassSendTypes)
        {
            sb.AppendLine($"{bodyIndent}types.Add(typeof({type}));");
        }

        // Add handler-level send types
        foreach (var handler in info.Handlers)
        {
            foreach (var type in handler.SendTypes)
            {
                sb.AppendLine($"{bodyIndent}types.Add(typeof({type}));");
            }
        }

        sb.AppendLine($"{bodyIndent}return types;");
        sb.AppendLine($"{indent}}}");
    }

    private static void GenerateConfigureYieldTypes(StringBuilder sb, ExecutorInfo info, string indent)
    {
        sb.AppendLine($"{indent}protected override ISet<Type> ConfigureYieldTypes()");
        sb.AppendLine($"{indent}{{");

        var bodyIndent = indent + "    ";

        sb.AppendLine($"{bodyIndent}var types = base.ConfigureYieldTypes();");

        // Track types we've already added to avoid duplicates
        var addedTypes = new HashSet<string>();

        // Add class-level yield types
        foreach (var type in info.ClassYieldTypes)
        {
            if (addedTypes.Add(type))
            {
                sb.AppendLine($"{bodyIndent}types.Add(typeof({type}));");
            }
        }

        // Add handler-level yield types and output types
        foreach (var handler in info.Handlers)
        {
            // Add explicit yield types
            foreach (var type in handler.YieldTypes)
            {
                if (addedTypes.Add(type))
                {
                    sb.AppendLine($"{bodyIndent}types.Add(typeof({type}));");
                }
            }

            // Add output type from return type
            if (handler.HasOutput && handler.OutputTypeName != null && addedTypes.Add(handler.OutputTypeName))
            {
                sb.AppendLine($"{bodyIndent}types.Add(typeof({handler.OutputTypeName}));");
            }
        }

        sb.AppendLine($"{bodyIndent}return types;");
        sb.AppendLine($"{indent}}}");
    }
}
