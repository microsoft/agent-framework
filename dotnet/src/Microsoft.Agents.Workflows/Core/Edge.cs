// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using Microsoft.Shared.Diagnostics;

using PartitionerT = System.Func<object?, int, System.Collections.Generic.IEnumerable<int>>;
using PredicateT = System.Func<object?, bool>;

namespace Microsoft.Agents.Workflows.Core;

/// <summary>
/// Represents a directed edge between two nodes, optionally associated with a condition that determines whether the
/// edge is active.
/// </summary>
/// <param name="sourceId">The id of the source executor node.</param>
/// <param name="sinkId">The id of the target executor node.</param>
/// <param name="condition">A predicate determining whether the edge is active for a given message.</param>
public sealed class DirectEdgeData(string sourceId, string sinkId, PredicateT? condition = null)
{
    /// <summary>
    /// The Id of the source <see cref="ExecutorBase"/> node.
    /// </summary>
    public string SourceId => sourceId;

    /// <summary>
    /// The Id of the destination <see cref="ExecutorBase"/> node.
    /// </summary>
    public string SinkId => sinkId;

    /// <summary>
    /// An optional predicate determining whether the edge is active for a given message. If <see langword="null"/>,
    /// the edge is always active when a message is generated by the source.
    /// </summary>
    public PredicateT? Condition => condition;
}

/// <summary>
/// Represents a connection from a single node to a set of nodes, optionally associated with a paritition selector
/// function which maps incoming messages to a subset of the target set.
/// </summary>
/// <param name="sourceId">The id of the source executor node.</param>
/// <param name="sinkIds">A list of ids of the target executor nodes.</param>
/// <param name="partitioner">A function that maps an incoming message to a subset of the target executor nodes.</param>
public sealed class FanOutEdgeData(
    string sourceId,
    List<string> sinkIds,
    PartitionerT? partitioner = null)
{
    /// <summary>
    /// The Id of the source <see cref="ExecutorBase"/> node.
    /// </summary>
    public string SourceId => sourceId;

    /// <summary>
    /// The ordered list of Ids of the destination <see cref="ExecutorBase"/> nodes.
    /// </summary>
    public List<string> SinkIds => sinkIds;

    /// <summary>
    /// A function mapping an incoming message to a subset of the target executor nodes (or optionally all of them).
    /// If <see langword="null"/>, all destination nodes are selected.
    /// </summary>
    public PartitionerT? PartitionAssigner => partitioner;
}

/// <summary>
/// Represents a connection from a set of nodes to a single node. It will trigger either when all edges have data.
/// </summary>
/// <param name="sourceIds">An enumeration of ids of the source executor nodes.</param>
/// <param name="sinkId">The id of the target executor node.</param>
public sealed class FanInEdgeData(List<string> sourceIds, string sinkId)
{
    /// <summary>
    /// The ordered list of Ids of the source <see cref="ExecutorBase"/> nodes.
    /// </summary>
    public List<string> SourceIds => sourceIds;

    /// <summary>
    /// The Id of the destination <see cref="ExecutorBase"/> node.
    /// </summary>
    public string SinkId => sinkId;

    internal Guid UniqueKey { get; } = Guid.NewGuid();
}

/// <summary>
/// Represents a connection or relationship between nodes, characterized by its type and associated data.
/// </summary>
/// <remarks>
/// An <see cref="Edge"/> can be of type <see cref="Type.Direct"/>, <see cref="Type.FanOut"/>, or <see
/// cref="Type.FanIn"/>, as specified by the <see cref="EdgeType"/> property. The <see cref="Data"/> property holds
/// additional information relevant to the edge, and its concrete type depends on the value of <see
/// cref="EdgeType"/>, functioning as a tagged union.
/// </remarks>
public sealed class Edge
{
    /// <summary>
    /// Specified the edge type.
    /// </summary>
    public enum Type
    {
        /// <summary>
        /// A direct connection from one node to another.
        /// </summary>
        Direct,
        /// <summary>
        /// A connection from one node to a set of nodes.
        /// </summary>
        FanOut,
        /// <summary>
        /// A connection from a set of nodes to a single node.
        /// </summary>
        FanIn
    }

    /// <summary>
    /// Specifies the type of the edge, which determines how the edge is processed in the workflow.
    /// </summary>
    public Type EdgeType { get; init; }

    /// <summary>
    /// The <see cref="Type"/>-dependent edge data.
    /// </summary>
    /// <seealso cref="DirectEdgeData"/>
    /// <seealso cref="FanOutEdgeData"/>
    /// <seealso cref="FanInEdgeData"/>
    public object Data { get; init; }

    internal Edge(DirectEdgeData data)
    {
        this.Data = Throw.IfNull(data);

        this.EdgeType = Type.Direct;
    }

    internal Edge(FanOutEdgeData data)
    {
        this.Data = Throw.IfNull(data);

        this.EdgeType = Type.FanOut;
    }

    internal Edge(FanInEdgeData data)
    {
        this.Data = Throw.IfNull(data);

        this.EdgeType = Type.FanIn;
    }

    internal DirectEdgeData? DirectEdgeData => this.Data as DirectEdgeData;
    internal FanOutEdgeData? FanOutEdgeData => this.Data as FanOutEdgeData;
    internal FanInEdgeData? FanInEdgeData => this.Data as FanInEdgeData;
}
