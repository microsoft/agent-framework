import asyncio

from agent_framework_redis._provider import RedisProvider


async def main():

    ''' 
    Purpose
    -------
    Validate provider-scoped filtering: partition IDs are defined on the provider
    (application_id, agent_id, user_id) and are ALWAYS applied to every search.
    Query-time filters cannot override these IDs.

    What this script does
    ---------------------
    1) Creates a new index (drops if exists) with provider scope set to:
       application_id=appA, agent_id=agentX, user_id=u1
    2) Inserts a mix of documents, some matching the provider scope and others not.
    3) Runs three validations:
       - Basic search for 'hello' returns only results within the provider scope.
       - Attempting to force a different user_id via filter yields 0 results.
       - Non-ID filter (role) still works within provider scope.
    '''
    provider = RedisProvider(
        redis_url="redis://localhost:6379",
        overwrite_redis_index=True,
        drop_redis_index=True,
        application_id="appA",
        agent_id="agentX",
        user_id="u1",
    )

    print("\n[1/4] Creating index...")
    await provider.create_redis_index()

    # Mix of docs; only those matching provider scope (appA, agentX, u1) should be returned
    test_data = [
        {"role": "user", "content": "Hello from u1 in appA."},
        {"role": "bot", "content": "Hello again, world from u1 in appA."},
        {"role": "user", "content": "Hello from u1 in appB.", "application_id": "appB"},
        {"role": "user", "content": "Hello from u2 in appA.", "user_id": "u2"},
        {"role": "user", "content": "Irrelevant text", "user_id": "u2", "application_id": "appB"},
    ]
    print("[2/4] Inserting mixed-scope documents...")
    await provider.add(data=test_data)

    exists = await provider.redis_index.exists()
    print("Index exists?", exists, "(Expected: True)")

    info = await provider.redis_index.info()
    print("Index info:", info)

    # 1) Basic search within provider scope
    print("\n[3/4] Basic search within provider scope...")
    res_all = await provider.text_search("hello")
    print("Search 'hello' within provider scope ->", len(res_all), "(Expected: 2)")
    for r in res_all:
        print({k: r.get(k) for k in ["content", "role", "application_id", "agent_id", "user_id"]})
    assert all(
        r.get("application_id") == "appA" and r.get("agent_id") == "agentX" and r.get("user_id") == "u1"
        for r in res_all
    )

    # 2) Attempt to override user_id at query time: should return 0 (conflicts with provider scope)
    print("\n[4/4] Attempt to override provider-scoped user_id at query time...")
    res_override = await provider.text_search("hello", filter_expression="@user_id:{u2}")
    print("Attempt override @user_id:{u2} ->", len(res_override), "(Expected: 0)")
    assert len(res_override) == 0

    # 3) Non-ID filtering still works (e.g., role) within provider scope
    res_role_user = await provider.text_search("hello", filter_expression="@role:{user}")
    print("Filter by role within scope ->", len(res_role_user), "(Expected: 1)")
    assert all(r.get("role") == "user" and r.get("user_id") == "u1" for r in res_role_user)

    print("\nAll validation checks passed.")

    # Example expected output (truncated):
    # [1/4] Creating index...
    # [2/4] Inserting mixed-scope documents...
    # Index exists? True (Expected: True)
    # Index info: {...}
    #
    # [3/4] Basic search within provider scope...
    # Search 'hello' within provider scope -> 2 (Expected: 2)
    # {'content': 'Hello from u1 in appA.', 'role': 'user', 'application_id': 'appA', 'agent_id': 'agentX', 'user_id': 'u1'}
    # {'content': 'Hello again, world from u1 in appA.', 'role': 'bot', 'application_id': 'appA', 'agent_id': 'agentX', 'user_id': 'u1'}
    #
    # [4/4] Attempt to override provider-scoped user_id at query time...
    # Attempt override @user_id:{u2} -> 0 (Expected: 0)
    # Filter by role within scope -> 1 (Expected: 1)
    #
    # All validation checks passed.


if __name__ == "__main__":
    asyncio.run(main())
