# Copyright (c) Microsoft. All rights reserved.

"""
Step 05 — Shared States

This sample improves on Step 04 by storing email content once in shared state and routing using a
structured spam detection result that includes an email_id generated by an executor.

Key improvements:
- Email content is stored once in shared state (no duplication in messages)
- Executors access shared data rather than passing it through
- Same workflow logic (spam detection → appropriate handling) with cleaner implementation
"""

import asyncio
import os
from dataclasses import dataclass
from typing import Any
from uuid import uuid4

from agent_framework import ChatMessage, ChatRole
from agent_framework.azure import AzureChatClient
from agent_framework.workflow import (
    AgentExecutor,
    AgentExecutorRequest,
    AgentExecutorResponse,
    WorkflowBuilder,
    WorkflowCompletedEvent,
    WorkflowContext,
    executor,
)
from azure.identity import AzureCliCredential
from pydantic import BaseModel

EMAIL_STATE_PREFIX = "email:"
CURRENT_EMAIL_ID_KEY = "current_email_id"


class DetectionResultAgent(BaseModel):
    """Structured output returned by the spam detection agent."""

    is_spam: bool
    reason: str


class EmailResponse(BaseModel):
    """Structured output returned by the email assistant agent."""

    response: str


@dataclass
class DetectionResult:
    """Internal detection result enriched with the shared-state email_id."""

    is_spam: bool
    reason: str
    email_id: str


@dataclass
class Email:
    email_id: str
    email_content: str


def get_condition(expected_result: bool):
    """Create a condition callable for DetectionResult.is_spam.

    Mirrors .NET: if the message isn't a DetectionResult, allow it to pass through.
    """

    def condition(message: Any) -> bool:
        if not isinstance(message, DetectionResult):
            return True
        return message.is_spam == expected_result

    return condition


@executor(id="store_email")
async def store_email(email_text: str, ctx: WorkflowContext[AgentExecutorRequest]) -> None:
    """Store the email once and submit a request for the spam detection agent."""
    new_email = Email(email_id=str(uuid4()), email_content=email_text)
    await ctx.set_shared_state(f"{EMAIL_STATE_PREFIX}{new_email.email_id}", new_email)
    await ctx.set_shared_state(CURRENT_EMAIL_ID_KEY, new_email.email_id)

    await ctx.send_message(
        AgentExecutorRequest(messages=[ChatMessage(ChatRole.USER, text=new_email.email_content)], should_respond=True)
    )


@executor(id="to_detection_result")
async def to_detection_result(response: AgentExecutorResponse, ctx: WorkflowContext[DetectionResult]) -> None:
    """Parse DetectionResultAgent and attach email_id from shared state."""
    parsed = DetectionResultAgent.model_validate_json(response.agent_run_response.text)
    email_id: str = await ctx.get_shared_state(CURRENT_EMAIL_ID_KEY)
    await ctx.send_message(DetectionResult(is_spam=parsed.is_spam, reason=parsed.reason, email_id=email_id))


@executor(id="submit_to_email_assistant")
async def submit_to_email_assistant(detection: DetectionResult, ctx: WorkflowContext[AgentExecutorRequest]) -> None:
    if detection.is_spam:
        raise RuntimeError("This executor should only handle non-spam messages.")

    email: Email = await ctx.get_shared_state(f"{EMAIL_STATE_PREFIX}{detection.email_id}")
    await ctx.send_message(
        AgentExecutorRequest(messages=[ChatMessage(ChatRole.USER, text=email.email_content)], should_respond=True)
    )


@executor(id="finalize_and_send")
async def finalize_and_send(response: AgentExecutorResponse, ctx: WorkflowContext[None]) -> None:
    parsed = EmailResponse.model_validate_json(response.agent_run_response.text)
    await ctx.add_event(WorkflowCompletedEvent(f"Email sent: {parsed.response}"))


@executor(id="handle_spam")
async def handle_spam(detection: DetectionResult, ctx: WorkflowContext[None]) -> None:
    if detection.is_spam:
        await ctx.add_event(WorkflowCompletedEvent(f"Email marked as spam: {detection.reason}"))
    else:
        raise RuntimeError("This executor should only handle spam messages.")


async def main() -> None:
    # Create chat client and agents
    chat_client = AzureChatClient(credential=AzureCliCredential())

    spam_detection_agent = AgentExecutor(
        chat_client.create_agent(
            instructions=(
                "You are a spam detection assistant that identifies spam emails. "
                "Always return JSON with fields is_spam (bool) and reason (string)."
            ),
            response_format=DetectionResultAgent,
        ),
        id="spam_detection_agent",
    )

    email_assistant_agent = AgentExecutor(
        chat_client.create_agent(
            instructions=(
                "You are an email assistant that helps users draft responses to emails with professionalism. "
                "Return JSON with a single field 'response' containing the drafted reply."
            ),
            response_format=EmailResponse,
        ),
        id="email_assistant_agent",
    )

    # Build the workflow
    workflow = (
        WorkflowBuilder()
        .set_start_executor(store_email)
        .add_edge(store_email, spam_detection_agent)
        .add_edge(spam_detection_agent, to_detection_result)
        .add_edge(to_detection_result, submit_to_email_assistant, condition=get_condition(False))
        .add_edge(to_detection_result, handle_spam, condition=get_condition(True))
        .add_edge(submit_to_email_assistant, email_assistant_agent)
        .add_edge(email_assistant_agent, finalize_and_send)
        .build()
    )

    # Read an email from resources/spam.txt if available; otherwise use a default sample
    resources_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "resources", "spam.txt")
    if os.path.exists(resources_path):
        with open(resources_path, encoding="utf-8") as f:  # noqa: ASYNC230
            email = f.read()
    else:
        email = "You are a WINNER! Click here for a free lottery offer!!!"

    # Run the workflow
    async for event in workflow.run_streaming(email):
        if isinstance(event, WorkflowCompletedEvent):
            print(f"{event}")

    """
    Sample Output:

    WorkflowCompletedEvent(data=Email marked as spam: This email exhibits several common spam and scam characteristics:
    unrealistic claims of large cash winnings, urgent time pressure, requests for sensitive personal and financial
    information, and a demand for a processing fee. The sender impersonates a generic lottery commission, and the
    message contains a suspicious link. All these are typical of phishing and lottery scam emails.)
    """


if __name__ == "__main__":
    asyncio.run(main())
