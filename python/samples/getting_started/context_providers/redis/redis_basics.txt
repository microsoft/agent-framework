import asyncio

from agent_framework import ChatMessage, Role
from agent_framework_redis._provider import RedisProvider


async def main() -> None:
    """Redis context provider standalone basic usage. 
    
    Initialize the provider with OpenAI vectorizer and API key.
    
    Useful Debug Commands:

    # Print index info
    print(await provider.redis_index.info())

    # Print all data stored in the index 
    print(await provider.search_all())
    """

    OPENAI_API_KEY = ""

    provider = RedisProvider(
        redis_url="redis://localhost:6379",
        index_name="redis_basics",
        overwrite_redis_index=True,
        drop_redis_index=True,
        application_id="matrix_of_kermits",
        agent_id="agent_kermit",
        user_id="kermit",
        vectorizer_choice="openai",
        vector_field_name="vector",
        vectorizer_api_key=OPENAI_API_KEY
    )
    
    messages = [
        ChatMessage(role=Role.USER, text="A: User Message"),
        ChatMessage(role=Role.ASSISTANT, text="B: Assistant Message"),
        ChatMessage(role=Role.SYSTEM, text="C: System Message"),
    ]

    await provider.messages_adding(thread_id="runA", new_messages=messages)

    ctx = await provider.model_invoking([
        ChatMessage(role=Role.USER, text="B: Assistant Message"),
        ChatMessage(role=Role.SYSTEM, text="B: Assistant Message"),
    ])

    print(ctx.contents[0].text)


    # Each record in Redis should be associated with agent_id or user_id or application_id or thread_id.
    # In this example, we associate Redis records with user_id.

    # For Azure authentication, run `az login` command in terminal or replace AzureCliCredential with preferred
    # authentication option.
    # For Redis authentication, set Redis API key via "api_key" parameter or Redis_API_KEY environment variable.
    # async with (
    #     OpenAIChatClient(
    #         env_file_path="/Users/han.choong/Desktop/projects/agent-framework/python/.env",
    #         instruction_role="assistant",
    #         context_providers=RedisProvider(),
    #     ) as agent,
    # ):
        # First ask the agent to retrieve a company report with no previous context.
        # The agent will not be able to invoke the tool, since it doesn't know
        # the company code or the report format, so it should ask for clarification.
        # query = "Please retrieve my company report"
        # print(f"User: {query}")
        # result = await agent.run(query)
        # print(f"Agent: {result}\n")

        # # Now tell the agent the company code and the report format that you want to use
        # # and it should be able to invoke the tool and return the report.
        # query = "I always work with CNTS and I always want a detailed report format. Please remember and retrieve it."
        # print(f"User: {query}")
        # result = await agent.run(query)
        # print(f"Agent: {result}\n")

        # print("\nRequest within a new thread:")
        # # Create a new thread for the agent.
        # # The new thread has no context of the previous conversation.
        # thread = agent.get_new_thread()

        # # Since we have the Redis component in the thread, the agent should be able to
        # # retrieve the company report without asking for clarification, as it will
        # # be able to remember the user preferences from Redis component.
        # query = "Please retrieve my company report"
        # print(f"User: {query}")
        # result = await agent.run(query, thread=thread)
        # print(f"Agent: {result}\n")


if __name__ == "__main__":
    asyncio.run(main())


# async def main():

#     ''' 
#     Purpose
#     -------
#     Validate provider-scoped filtering: partition IDs are defined on the provider
#     (application_id, agent_id, user_id) and are ALWAYS applied to every search.
#     Query-time filters cannot override these IDs.

#     What this script does
#     ---------------------
#     1) Creates a new index (drops if exists) with provider scope set to:
#        application_id=appA, agent_id=agentX, user_id=u1
#     2) Inserts a mix of documents, some matching the provider scope and others not.
#     3) Runs three validations:
#        - Basic search for 'hello' returns only results within the provider scope.
#        - Attempting to force a different user_id via filter yields 0 results.
#        - Non-ID filter (role) still works within provider scope.
#     '''
#     provider = RedisProvider(
#         redis_url="redis://localhost:6379",
#         overwrite_redis_index=True,
#         drop_redis_index=True,
#         application_id="appA",
#         agent_id="agentX",
#         user_id="u1",
#         vectorizer_choice="openai",
#         vector_field_name="vector",
#     )

#     print("\n[1/4] Creating index...")
#     await provider.create_redis_index()

#     # Insert via messages_adding (provider-scoped). Only these should be visible to this provider.
#     messages_in_scope = [
#         ChatMessage(role=Role.USER, text="Hello from u1 in appA."),
#         ChatMessage(role=Role.ASSISTANT, text="Hello again, world from u1 in appA."),
#         ChatMessage(role=Role.SYSTEM, text="System notice within appA/u1."),
#     ]
#     print("[2/4] Inserting in-scope messages via messages_adding()...")
#     await provider.messages_adding(thread_id="runA", new_messages=messages_in_scope)

#     # Insert out-of-scope messages via a second provider (different user/app)
#     other = RedisProvider(
#         redis_url="redis://localhost:6379",
#         overwrite_redis_index=False,
#         drop_redis_index=False,
#         application_id="appB",
#         agent_id="agentX",
#         user_id="u2",
#         vectorizer_choice="openai",
#         vector_field_name="vector",
#     )
#     messages_out_of_scope = [
#         ChatMessage(role=Role.USER, text="Hello from u2 in appB (should be invisible to appA/u1)."),
#         ChatMessage(role=Role.ASSISTANT, text="Another hello from u2/appB (out of scope)."),
#     ]
#     await other.messages_adding(thread_id="runB", new_messages=messages_out_of_scope)

#     exists = await provider.redis_index.exists()
#     print("Index exists?", exists, "(Expected: True)")

#     info = await provider.redis_index.info()
#     print("Index info:", info)

#     # 1) Basic context retrieval via model_invoking (drives search)
#     print("\n[3/4] model_invoking triggers scoped search and returns context...")
#     ctx = await provider.model_invoking([
#         ChatMessage(role=Role.USER, text="hello"),
#         ChatMessage(role=Role.ASSISTANT, text="reply"),
#     ])
#     # Print the instruction content returned
#     contents = getattr(ctx, "contents", None) or []
#     print("Context contents count:", len(contents))
#     if contents:
#         first = contents[0]
#         text = getattr(first, "text", None) or getattr(first, "data", None)
#         print("Context preview:\n", str(text)[:300])

#     # 2) Attempt to override user_id at query time via search (still unsupported)
#     print("\n[4/4] Attempt to override provider-scoped user_id at query time...")
#     res_override = await provider.redis_search("hello", filter_expression="@user_id:{u2}")
#     print("Attempt override @user_id:{u2} ->", len(res_override), "(Expected: 0)")
#     assert len(res_override) == 0

#     # 3) Non-ID filtering still works (e.g., role) within provider scope
#     res_role_user = await provider.redis_search("hello", filter_expression="@role:{user}")
#     print("Filter by role within scope ->", len(res_role_user), "(Expected: 1)")
#     assert all(r.get("role") == "user" and r.get("user_id") == "u1" for r in res_role_user)

#     print("\nAll validation checks passed.")

#     # Example expected output (truncated):
#     # [1/4] Creating index...
#     # [2/4] Inserting in-scope messages via messages_adding()...
#     # Index exists? True (Expected: True)
#     # Index info: {...}
#     #
#     # [3/4] Basic search within provider scope...
#     # Search 'hello' within provider scope -> 2 (Expected: 2)
#     # {'content': 'Hello from u1 in appA.', 'role': 'user', 'application_id': 'appA', 'agent_id': 'agentX', 'user_id': 'u1'}
#     # {'content': 'Hello again, world from u1 in appA.', 'role': 'assistant', 'application_id': 'appA', 'agent_id': 'agentX', 'user_id': 'u1'}
#     #
#     # [4/4] Attempt to override provider-scoped user_id at query time...
#     # Attempt override @user_id:{u2} -> 0 (Expected: 0)
#     # Filter by role within scope -> 1 (Expected: 1)
#     #
#     # All validation checks passed.


# if __name__ == "__main__":
#     asyncio.run(main())
